from .mode import Mode
from cv2 import TERM_CRITERIA_EPS, TERM_CRITERIA_MAX_ITER, KMEANS_RANDOM_CENTERS, kmeans, cvtColor, COLOR_BGR2GRAY, medianBlur, adaptiveThreshold, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, COLOR_GRAY2BGR, addWeighted
import numpy as np

#Method to get Colour from K means was from:
# Dominant Colors Extraction with OpenCV- https://www.youtube.com/watch?v=90s4SomOSa0&t=0s

class LowHealth(Mode):
      
    """A class that represents the low health mode.

        This mode tracks the health of the player and displays a red effect on the screen when the player is low on health.


        Methods:
            kmeans_get_colour(data):
                Runs the k-means algorithm from OpenCV on the input data to get the dominant color.
            
            crop_and_resize_image_to_data(frame):
                Crops the original image to the left and right sides of the screen and concatenates the data into one big image.
                This big image is then passed to kmeans.
            
            scale_low_health_to_frames(colour):
                Scales the color obtained from the k-means algorithm to a frame number between 0 and num_low_health_frames.
                The scaling is linear and the range is between 1.2 and 2.5.
            
            generate_low_health_frames():
                Generates a list of specified number of frames with a red tint.
                The red tint ranges from 0 (fully transparent) to num_low_health_frames (almost fully red).
                This list of frames is used to create the low health effect.
                The frames are generated by adding the red tint to the background image.

    """
      
    def __init__(
            self,
            settings_access,
            display_capture,  
            background_img,
            audio_capture=None
        ):
        self.settings_access = settings_access
        self.background_img = background_img
        self.display_capture = display_capture
        self.num_low_health_frames = settings_access.read_mode_settings("low_health","num_low_health_frames")
        #print(self.num_low_health_frames)
        self.low_health_frames = self.generate_low_health_frames()

        self.number_clusters = 1
        self.criteria = (TERM_CRITERIA_EPS + TERM_CRITERIA_MAX_ITER, 10, 1.0)
        self.flags = KMEANS_RANDOM_CENTERS

        self.previous_avgBG = None
        self.start_low_health = 1.2
        self.end_low_health = 2.5
        self.range = self.end_low_health - self.start_low_health
        self.scaling_factor = self.num_low_health_frames/self.range
    
        
    def kmeans_get_colour(self, data):

        """
        Run the Kmeans algorithm from CV2 on the frame data to get the dominant colour.
        The dominant colour is returned in the colour list, since only 1 cluster is used, it is the first element.

        Parameters:
        - data: A numpy array containing pixel data.

        Returns:
        - The dominant colour in the form of a numpy array.
        """
          
        #Run the Kmeans algorith from CV2 on the frame data to get the dominant colour
        #The dominant colour is returned in the colour list, since only 1 cluster is used, it is the first element 
        _, _, colour_list = kmeans(data, self.number_clusters, None, self.criteria, 10, self.flags)
        return colour_list[0]

    def crop_and_resize_image_to_data(self,frame):

        """
        Crop the original image to the left and right sides of the screen, forming sct_left and sct_right.
        In games, often the sides of the screen are where blood splatters are shown.
        Reshape and concatenate data from images into 1 big image, to be passed to kmeans.

        Parameters:
        - frame: A numpy array containing frame data.

        Returns:
        - A numpy array of the concatenated data from both the left and right sides of the frame.
        """

        #Crop the original image to the left and right sides of the screen, forming 
        #sct_left and sct_right
        #In games, often the sides of the screen are where blood splatters are shown
        height, width, _ = np.shape(frame)
        x_left = 0
        x_right = int(width*7/8)
        w = int(width/8)

        y = int(height/8)
        h = int(height*6/8)
        sct_left = frame[y:y+h, x_left:x_left+w]
        sct_right = frame[y:y+h, x_right:x_right+w]

        #reshape and concatenate data from images into 1 big image, to be passed to kmeans
        height, width, _ = np.shape(sct_left)
        data_left = np.reshape(sct_left, (height * width, 3))
        data_left = np.float32(data_left) 

        height, width, _ = np.shape(sct_right)
        data_right = np.reshape(sct_left, (height * width, 3))
        data_right = np.float32(data_right) 

        data = np.concatenate((data_left,data_right))
        return data

    def scale_low_health_to_frames(self, colour):
        
        """
        Scale the red component of the given colour from 1.2 to 2.5 and convert to a frame number, using a linear scale.
        The output frame number is bounded by 0 and the number of low health frames, and is used to select a low health frame for display.

        Parameters:
            colour: A numpy array of the RGB components of a colour.

        Returns:
            The frame number to be used for displaying the selected frame.
        """
        
        b, g, r = colour
        avgBG = (b+g+1)/2
        #print("colour is: ",colour)
        #print("red/avg :",r/avgBG)
        frame_num = 0


        #In Bo2, anything below 1.2 is no blood, maximum of 2.5
        #Scale from 1.2, to 2.5 use linear scale for frame num
        #THerefore subtract 1.2 from each colour reading, then scale from 
        #0 to 1.3

        avgRBG = (r+1) / avgBG

        avgRBG_scaled = (avgRBG - self.start_low_health) * self.scaling_factor
        frame_num = int(avgRBG_scaled)

        if frame_num > self.num_low_health_frames:
            frame_num = self.num_low_health_frames - 1
        elif frame_num < 0:
            frame_num = 0
        #print("framenum:",frame_num)
        return frame_num
    
    def generate_low_health_frames(self):
        """
        Generate a specified number of low health frames, with increasing red component, and return them as a list.

        Returns:
            A list of generated low health frames, each represented as a numpy array.
        """
        
        gray = cvtColor(self.background_img, COLOR_BGR2GRAY)
        
        gray = medianBlur(gray, 5)
        
        # Detect edges in image, create colour image
        edges = adaptiveThreshold(
                    gray, 255, ADAPTIVE_THRESH_MEAN_C, 
                    THRESH_BINARY,11, 7
                )
        
        colour_edges = cvtColor(edges, COLOR_GRAY2BGR)       
        colour_edges[np.where((colour_edges == [0,0,0]).all(axis = 2))] = [0, 0, 0] #BGR - Colour of lines
        colour_edges[np.where((colour_edges == [255,255,255]).all(axis = 2))] = [0, 0, 200] #BGR - colour of background

        #Generate specified number of frames, first with 0 change in colour, get red until almost fully red
        generated_frames = []
        print("Generating Low Health Frames")
        for opacity in range(0,self.num_low_health_frames,1):
            opacity_background = round(1-opacity/self.num_low_health_frames,2)
            opacity_edges= round(opacity/self.num_low_health_frames,2)
            generated_frames.append(addWeighted(self.background_img, opacity_background, colour_edges, opacity_edges, -5))
        return generated_frames


    def trigger(self):

        """
        Capture a frame, crop and resize it, determine the dominant colour using Kmeans, scale the red component of the colour
        to a frame number, and select a low health frame for display.
        If the selected frame is close to the end of the list, it is repeated multiple times to prevent flicker.

        Returns:
            A list of frames to be displayed, each represented as a numpy array.
        """
        
        #Display capture 
        input_frame = self.display_capture.capture_frame()
        frames = [input_frame]

        data = self.crop_and_resize_image_to_data(input_frame)
        
        kmeans_colour = self.kmeans_get_colour(data)

        low_health_frame_num = self.scale_low_health_to_frames(kmeans_colour)

        #First check if low_health_frame_num is within the allowed range, if not, return the background frame

        if not(isinstance(low_health_frame_num, int) and (low_health_frame_num >= 0 and low_health_frame_num < self.num_low_health_frames)):
            return [self.background_img]
        else:
            if self.num_low_health_frames-low_health_frame_num > 0.8 * self.num_low_health_frames:
                frames = [self.low_health_frames[low_health_frame_num]] 
            else:
                frames = [self.low_health_frames[low_health_frame_num]] * (3)
        print("colour: ",kmeans_colour)
        print("frame num: ",low_health_frame_num)
        return frames


